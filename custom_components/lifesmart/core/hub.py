"""LifeSmart æ™ºèƒ½å®¶å±…ç³»ç»Ÿé›†æˆçš„ä¸­å¤®åè°ƒå™¨ Hubã€‚

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ—ï¸ æ¶æ„è®¾è®¡ç†å¿µ
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

æœ¬æ¨¡å—å®ç°äº† LifeSmart é›†æˆçš„æ ¸å¿ƒåè°ƒå™¨æ¨¡å¼ï¼Œé‡‡ç”¨ä¸‰å±‚æ¶æ„è®¾è®¡ï¼š

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ¯ ä¸šåŠ¡å±‚ (Hub Layer)                                                            â”‚
â”‚ â”œâ”€â”€ è®¾å¤‡ç”Ÿå‘½å‘¨æœŸç®¡ç†                                                             â”‚
â”‚ â”œâ”€â”€ å®æ—¶çŠ¶æ€æ›´æ–°åˆ†å‘                                                             â”‚
â”‚ â”œâ”€â”€ è®¾å¤‡è¿‡æ»¤å’ŒAIäº‹ä»¶å¤„ç†                                                         â”‚
â”‚ â””â”€â”€ ç»Ÿä¸€æ•°æ®è®¿é—®æ¥å£                                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ”Œ é€šä¿¡å±‚ (Communication Layer)                                                  â”‚
â”‚ â”œâ”€â”€ OAPIå®¢æˆ·ç«¯ (äº‘ç«¯REST + WebSocket)                                           â”‚
â”‚ â”œâ”€â”€ Local TCPå®¢æˆ·ç«¯ (æœ¬åœ°ç½‘å…³ç›´è¿)                                              â”‚
â”‚ â””â”€â”€ è‡ªé€‚åº”ç½‘ç»œè´¨é‡æ£€æµ‹                                                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âš¡ åŸºç¡€è®¾æ–½å±‚ (Infrastructure Layer)                                            â”‚
â”‚ â”œâ”€â”€ å¹¶å‘æ§åˆ¶ç®¡ç†å™¨ (é˜²æ­¢ç«æ€æ¡ä»¶)                                               â”‚
â”‚ â”œâ”€â”€ WebSocketçŠ¶æ€ç®¡ç†å™¨ (é•¿è¿æ¥ç»´æŠ¤)                                            â”‚
â”‚ â”œâ”€â”€ ä»¤ç‰Œç”Ÿå‘½å‘¨æœŸç®¡ç†                                                             â”‚
â”‚ â””â”€â”€ æ•…éšœæ£€æµ‹ä¸æ¢å¤æœºåˆ¶                                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ”¥ æ ¸å¿ƒåŠŸèƒ½ç‰¹æ€§
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ›ï¸  **åŒæ¨¡å¼é€šä¿¡æ”¯æŒ**
    - OAPIæ¨¡å¼ï¼šäº‘ç«¯REST API + WebSocketå®æ—¶æ¨é€
    - æœ¬åœ°æ¨¡å¼ï¼šTCPç›´è¿ç½‘å…³ï¼Œä½å»¶è¿Ÿæ§åˆ¶
    - åŠ¨æ€æ¨¡å¼åˆ‡æ¢å’Œæ•…éšœè½¬ç§»

ğŸ”„  **æ™ºèƒ½è®¾å¤‡çŠ¶æ€ç®¡ç†**
    - å®æ—¶WebSocketæ¨é€å¤„ç†
    - è®¾å¤‡çŠ¶æ€ç¼“å­˜å’Œå¢é‡æ›´æ–°
    - æ–­çº¿é‡è¿åçš„çŠ¶æ€åŒæ­¥ç­–ç•¥

ğŸ›¡ï¸  **ä¼ä¸šçº§å¹¶å‘æ§åˆ¶**
    - ä»¤ç‰Œåˆ·æ–°é˜²ç«æ€ä¿æŠ¤
    - è®¾å¤‡æ›´æ–°å¹¶å‘é™åˆ¶
    - WebSocketè¿æ¥ç‹¬å é”
    - æ¶ˆæ¯å¤„ç†å¼‚æ­¥é˜Ÿåˆ—

ğŸŒ  **ç½‘ç»œè´¨é‡è‡ªé€‚åº”**
    - å®æ—¶ç½‘ç»œè´¨é‡æ£€æµ‹
    - åŠ¨æ€è°ƒæ•´å¿ƒè·³é—´éš”
    - æ™ºèƒ½é‡è¿å»¶è¿Ÿç®—æ³•
    - ç½‘ç»œå¼‚å¸¸é¢„æµ‹å’Œé¢„å¤„ç†

ğŸ”§  **ç”Ÿäº§çº§é”™è¯¯å¤„ç†**
    - å¤šå±‚å¼‚å¸¸æ•è·å’Œåˆ†ç±»
    - è®¾å¤‡é—®é¢˜æ ‡è®°å’Œè·Ÿè¸ª
    - è‡ªåŠ¨æ•…éšœæ¢å¤æµç¨‹
    - è¯¦ç»†çš„è¯Šæ–­ä¿¡æ¯è®°å½•

ğŸ’¡  **é«˜çº§åŠŸèƒ½é›†æˆ**
    - è®¾å¤‡å’Œç½‘å…³è¿‡æ»¤é…ç½®
    - AIäº‹ä»¶ç‰¹æ®Šå¤„ç†
    - Home AssistantåŸç”Ÿé›†æˆ
    - å®æ—¶è¯Šæ–­ç»Ÿè®¡æ¥å£

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âš ï¸  å…³é”®æŠ€æœ¯è€ƒè™‘
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ” **å®‰å…¨æ€§**ï¼šä»¤ç‰Œå®‰å…¨å­˜å‚¨ã€WebSocketè®¤è¯ã€æœ¬åœ°è¿æ¥åŠ å¯†
ğŸš€ **æ€§èƒ½**ï¼šå¼‚æ­¥I/Oã€æ¶ˆæ¯é˜Ÿåˆ—ã€è®¾å¤‡çŠ¶æ€ç¼“å­˜ã€ç½‘ç»œä¼˜åŒ–
ğŸ›¡ï¸ **å¯é æ€§**ï¼šæ•…éšœæ£€æµ‹ã€è‡ªåŠ¨é‡è¿ã€æ•°æ®ä¸€è‡´æ€§ä¿è¯
ğŸ“Š **å¯è§‚æµ‹æ€§**ï¼šè¯¦ç»†æ—¥å¿—ã€æ€§èƒ½ç»Ÿè®¡ã€ç½‘ç»œè´¨é‡ç›‘æ§
ğŸ”§ **å¯ç»´æŠ¤æ€§**ï¼šæ¨¡å—åŒ–è®¾è®¡ã€æ¸…æ™°æ¥å£ã€å®Œæ•´æµ‹è¯•è¦†ç›–

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ä½œè€…ï¼š@MapleEve
ç‰ˆæœ¬ï¼šv2.0 (æ¶æ„é‡æ„ç‰ˆ)
åˆ›å»ºæ—¥æœŸï¼š2024å¹´
æ›´æ–°æ—¥æœŸï¼š2025å¹´8æœˆ
è®¸å¯ï¼šéµå¾ªé¡¹ç›®å¼€æºè®¸å¯è¯
"""

import asyncio
import json
import logging
import time
from datetime import datetime, timedelta
from typing import Optional, Callable, Dict, Any

import aiohttp
from homeassistant.config_entries import CONN_CLASS_CLOUD_PUSH, ConfigEntry
from homeassistant.const import (
    CONF_HOST,
    CONF_PASSWORD,
    CONF_PORT,
    CONF_REGION,
    CONF_TYPE,
    CONF_USERNAME,
)
from homeassistant.core import HomeAssistant
from homeassistant.exceptions import ConfigEntryNotReady
from homeassistant.helpers import device_registry as dr
from homeassistant.helpers.aiohttp_client import async_get_clientsession
from homeassistant.helpers.dispatcher import dispatcher_send
from homeassistant.helpers.event import async_track_time_interval

from .client import LifeSmartTCPClient, LifeSmartOpenAPIClient
from .client_base import LifeSmartClientBase
from .compatibility import get_ws_timeout
from .concurrency_manager import ConcurrencyManager
from .const import (
    CONF_AI_INCLUDE_AGTS,
    CONF_AI_INCLUDE_ITEMS,
    CONF_EXCLUDE_AGTS,
    CONF_EXCLUDE_ITEMS,
    CONF_LIFESMART_APPKEY,
    CONF_LIFESMART_APPTOKEN,
    CONF_LIFESMART_AUTH_METHOD,
    CONF_LIFESMART_USERID,
    CONF_LIFESMART_USERPASSWORD,
    CONF_LIFESMART_USERTOKEN,
    CONF_WS_HEARTBEAT_INTERVAL,
    CONF_WS_MAX_RECONNECT_ATTEMPTS,
    CONF_WS_NETWORK_MODE,
    DEVICE_ID_KEY,
    DEVICE_TYPE_KEY,
    DOMAIN,
    HUB_ID_KEY,
    LIFESMART_SIGNAL_UPDATE_ENTITY,
    MANUFACTURER,
    SUBDEVICE_INDEX_KEY,
)
from .exceptions import LifeSmartAPIError, LifeSmartAuthError
from .helpers import generate_unique_id
from .network_quality_detector import NetworkQualityDetector, calculate_reconnect_delay

_LOGGER = logging.getLogger(__name__)


class LifeSmartHub:
    """LifeSmart æ™ºèƒ½å®¶å±…ç³»ç»Ÿé›†æˆçš„ä¸­å¤®åè°ƒå™¨æ ¸å¿ƒç±»ã€‚

    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    ğŸ¯ è®¾è®¡æ¨¡å¼ä¸æ¶æ„ç†å¿µ
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    æœ¬ç±»é‡‡ç”¨ **ä¸­å¤®åè°ƒå™¨æ¨¡å¼ (Central Coordinator Pattern)**ï¼Œä½œä¸ºæ•´ä¸ª LifeSmart
    é›†æˆçš„å•ä¸€å…¥å£ç‚¹å’ŒçŠ¶æ€ç®¡ç†ä¸­å¿ƒã€‚è®¾è®¡éµå¾ªä»¥ä¸‹æ ¸å¿ƒåŸåˆ™ï¼š

    ğŸ—ï¸ **å•ä¸€èŒè´£åŸåˆ™**ï¼šæ¯ä¸ªæ–¹æ³•ä¸“æ³¨äºä¸€ä¸ªç‰¹å®šçš„ä¸šåŠ¡åŠŸèƒ½
    ğŸ”’ **å°è£…æ€§åŸåˆ™**ï¼šå†…éƒ¨çŠ¶æ€é€šè¿‡å—æ§æ¥å£è®¿é—®
    ğŸ”— **ä¾èµ–æ³¨å…¥åŸåˆ™**ï¼šé€šè¿‡æ„é€ å‡½æ•°æ³¨å…¥æ ¸å¿ƒä¾èµ–
    â™»ï¸  **èµ„æºç”Ÿå‘½å‘¨æœŸç®¡ç†**ï¼šå®Œæ•´çš„åˆ›å»º-ä½¿ç”¨-é”€æ¯å¾ªç¯
    ğŸ›¡ï¸ **æ•…éšœéš”ç¦»åŸåˆ™**ï¼šé”™è¯¯ä¸ä¼šçº§è”å½±å“å…¶ä»–ç»„ä»¶

    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    ğŸ“‹ æ ¸å¿ƒèŒè´£æ¨¡å—
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    ğŸ”Œ **å®¢æˆ·ç«¯ç”Ÿå‘½å‘¨æœŸç®¡ç†**
       â”œâ”€â”€ æ ¹æ®é…ç½®åˆ›å»ºåˆé€‚çš„å®¢æˆ·ç«¯å®ä¾‹ (OAPI/TCP)
       â”œâ”€â”€ å¤„ç†å®¢æˆ·ç«¯è®¤è¯å’Œä»¤ç‰Œç®¡ç†
       â”œâ”€â”€ ç®¡ç†å®¢æˆ·ç«¯è¿æ¥çŠ¶æ€å’Œé‡è¿é€»è¾‘
       â””â”€â”€ æä¾›ç»Ÿä¸€çš„å®¢æˆ·ç«¯è®¿é—®æ¥å£

    ğŸ“Š **è®¾å¤‡æ•°æ®ä¸­å¿ƒåŒ–ç®¡ç†**
       â”œâ”€â”€ ç»´æŠ¤å…¨å±€è®¾å¤‡åˆ—è¡¨å’ŒçŠ¶æ€ç¼“å­˜
       â”œâ”€â”€ å¤„ç†è®¾å¤‡åˆ—è¡¨çš„å¢é‡å’Œå…¨é‡æ›´æ–°
       â”œâ”€â”€ å®ç°è®¾å¤‡æ•°æ®çš„è¿‡æ»¤å’Œç­›é€‰é€»è¾‘
       â””â”€â”€ ä¸ºå¹³å°å®ä½“æä¾›è®¾å¤‡æ•°æ®è®¿é—®

    ğŸ”„ **å®æ—¶çŠ¶æ€æ›´æ–°åˆ†å‘ç³»ç»Ÿ**
       â”œâ”€â”€ æ¥æ”¶WebSocket/TCPæ¨é€çš„è®¾å¤‡çŠ¶æ€å˜æ›´
       â”œâ”€â”€ è§£æå’ŒéªŒè¯çŠ¶æ€æ›´æ–°æ•°æ®çš„å®Œæ•´æ€§
       â”œâ”€â”€ é€šè¿‡Home Assistant dispatcheråˆ†å‘æ›´æ–°äº‹ä»¶
       â””â”€â”€ å¤„ç†ç‰¹æ®Šäº‹ä»¶ç±»å‹ (å¦‚AIäº‹ä»¶)

    ğŸŒ **WebSocketé•¿è¿æ¥ç»´æŠ¤**
       â”œâ”€â”€ ç®¡ç†ä¸LifeSmartäº‘ç«¯çš„WebSocketè¿æ¥
       â”œâ”€â”€ å¤„ç†è¿æ¥æ–­å¼€å’Œè‡ªåŠ¨é‡è¿é€»è¾‘
       â”œâ”€â”€ ç»´æŠ¤å¿ƒè·³å’Œç½‘ç»œè´¨é‡æ£€æµ‹
       â””â”€â”€ åè°ƒä»¤ç‰Œåˆ·æ–°å’Œè¿æ¥è®¤è¯

    ğŸ›¡ï¸ **æ•…éšœæ£€æµ‹ä¸æ¢å¤æœºåˆ¶**
       â”œâ”€â”€ ç›‘æ§å„ç»„ä»¶çš„å¥åº·çŠ¶æ€
       â”œâ”€â”€ å®ç°å¤šçº§æ•…éšœæ¢å¤ç­–ç•¥
       â”œâ”€â”€ è®°å½•å’Œåˆ†æè®¾å¤‡å¼‚å¸¸æ¨¡å¼
       â””â”€â”€ æä¾›æ•…éšœè¯Šæ–­å’Œç»Ÿè®¡æ¥å£

    Attributes:
        hass (HomeAssistant): Home Assistantæ ¸å¿ƒå®ä¾‹ï¼Œæä¾›å¼‚æ­¥äº‹ä»¶å¾ªç¯ç­‰
        config_entry (ConfigEntry): é›†æˆé…ç½®æ¡ç›®ï¼ŒåŒ…å«ç”¨æˆ·é…ç½®å’Œé€‰é¡¹
        client (Optional[LifeSmartClientBase]): ç»Ÿä¸€å®¢æˆ·ç«¯æ¥å£ (OAPI/TCP)
        devices (list[dict]): å…¨å±€è®¾å¤‡åˆ—è¡¨ç¼“å­˜ï¼Œæ”¯æŒè¿‡æ»¤å’Œå®æ—¶æ›´æ–°
        _state_manager (Optional[LifeSmartStateManager]): WebSocketçŠ¶æ€ç®¡ç†å™¨
        _local_task (Optional[asyncio.Task]): æœ¬åœ°TCPè¿æ¥ä»»åŠ¡
        _refresh_task_unsub (Optional[Callable]): å®šæ—¶åˆ·æ–°ä»»åŠ¡å–æ¶ˆå‡½æ•°
        _concurrency_manager (ConcurrencyManager): ä¼ä¸šçº§å¹¶å‘æ§åˆ¶ç®¡ç†å™¨
    """

    def __init__(self, hass: HomeAssistant, config_entry: ConfigEntry) -> None:
        """åˆå§‹åŒ– LifeSmart Hubã€‚

        Args:
            hass: Home Assistant æ ¸å¿ƒå®ä¾‹
            config_entry: é…ç½®æ¡ç›®å®ä¾‹
        """
        self.hass = hass
        self.config_entry = config_entry
        self.client: Optional[LifeSmartClientBase] = None
        self.devices: list[dict] = []
        self._state_manager: Optional[LifeSmartStateManager] = None
        self._local_task: Optional[asyncio.Task] = None
        self._refresh_task_unsub: Optional[Callable[[], None]] = None

        # åˆå§‹åŒ–å¹¶å‘æ§åˆ¶ç®¡ç†å™¨
        self._concurrency_manager = ConcurrencyManager()

        # ä¿æŒå‘åå…¼å®¹çš„é”å¼•ç”¨ï¼ˆå·²å¼ƒç”¨ï¼Œå°†åœ¨æœªæ¥ç‰ˆæœ¬ä¸­ç§»é™¤ï¼‰
        self._token_refresh_lock = self._concurrency_manager._token_refresh_lock
        self._device_update_semaphore = (
            self._concurrency_manager._device_update_semaphore
        )

    async def async_setup(self) -> bool:
        """å¼‚æ­¥è®¾ç½® Hubï¼ŒåŒ…æ‹¬å®¢æˆ·ç«¯åˆ›å»ºã€è®¾å¤‡è·å–å’Œåå°ä»»åŠ¡å¯åŠ¨ã€‚

        Returns:
            å¦‚æœè®¾ç½®æˆåŠŸè¿”å› Trueï¼Œå¦åˆ™è¿”å› False

        Raises:
            ConfigEntryNotReady: å¦‚æœè®¾ç½®è¿‡ç¨‹ä¸­å‘ç”Ÿå¯é‡è¯•çš„é”™è¯¯
        """
        try:
            # 1. åˆ›å»ºå®¢æˆ·ç«¯å¹¶è·å–è®¾å¤‡
            auth_response = await self._async_create_client_and_get_devices()

            # è®°å½•å¯åŠ¨æ—¶é—´ç”¨äºç»Ÿè®¡
            self._startup_time = datetime.now()

            # 2. æ³¨å†Œä¸­æ¢è®¾å¤‡
            await self._async_register_hubs()

            # 3. è®¾ç½®åå°ä»»åŠ¡
            await self._async_setup_background_tasks(auth_response)

            return True

        except (LifeSmartAuthError, ConfigEntryNotReady):
            raise
        except Exception as e:
            _LOGGER.error("è®¾ç½® LifeSmart Hub æ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯: %s", e, exc_info=True)
            raise ConfigEntryNotReady(f"Hub è®¾ç½®å¤±è´¥: {e}") from e

    async def _async_create_client_and_get_devices(self) -> Optional[dict]:
        """åˆ›å»ºå®¢æˆ·ç«¯å¹¶è·å–è®¾å¤‡åˆ—è¡¨ã€‚

        Returns:
            è®¤è¯å“åº”æ•°æ®ï¼ˆOAPI æ¨¡å¼ï¼‰æˆ– Noneï¼ˆæœ¬åœ°æ¨¡å¼ï¼‰

        Raises:
            LifeSmartAuthError: è®¤è¯å¤±è´¥
            ConfigEntryNotReady: ç½‘ç»œæˆ–å…¶ä»–å¯é‡è¯•é”™è¯¯
        """
        config_data = self.config_entry.data.copy()
        conn_type = config_data.get(CONF_TYPE, CONN_CLASS_CLOUD_PUSH)
        auth_response = None

        if conn_type == CONN_CLASS_CLOUD_PUSH:
            # OAPI æ¨¡å¼
            auth_response = await self._setup_oapi_client(config_data)
        else:
            # æœ¬åœ°æ¨¡å¼
            await self._setup_local_client()

        return auth_response

    async def _setup_oapi_client(self, config_data: dict) -> dict:
        """è®¾ç½® OAPI å®¢æˆ·ç«¯ã€‚

        Args:
            config_data: é…ç½®æ•°æ®

        Returns:
            è®¤è¯å“åº”æ•°æ®

        Raises:
            LifeSmartAuthError: è®¤è¯å¤±è´¥
            ConfigEntryNotReady: ç½‘ç»œé”™è¯¯
        """
        try:
            self.client = LifeSmartOpenAPIClient(
                self.hass,
                config_data.get(CONF_REGION),
                config_data.get(CONF_LIFESMART_APPKEY),
                config_data.get(CONF_LIFESMART_APPTOKEN),
                config_data.get(CONF_LIFESMART_USERTOKEN),
                config_data.get(CONF_LIFESMART_USERID),
                config_data.get(CONF_LIFESMART_USERPASSWORD),
            )

            # å¤„ç†è®¤è¯å’Œä»¤ç‰Œåˆ·æ–°
            auth_response = await self._handle_oapi_authentication(config_data)

            # è·å–è®¾å¤‡åˆ—è¡¨
            self.devices = await self.client.async_get_all_devices()
            return auth_response

        except LifeSmartAuthError as e:
            _LOGGER.error("OAPI å®¢æˆ·ç«¯è®¤è¯å¤±è´¥")
            raise ConfigEntryNotReady(f"è®¤è¯å¤±è´¥: {e}") from e
        except LifeSmartAPIError as e:
            _LOGGER.error("OAPI å®¢æˆ·ç«¯ API é”™è¯¯")
            raise ConfigEntryNotReady(f"APIé”™è¯¯: {e}") from e

    async def _handle_oapi_authentication(self, config_data: dict) -> dict:
        """å¤„ç† OAPI è®¤è¯æµç¨‹ã€‚

        Args:
            config_data: é…ç½®æ•°æ®

        Returns:
            è®¤è¯å“åº”æ•°æ®
        """
        auth_response = None

        # å¦‚æœä½¿ç”¨å¯†ç ç™»å½•ï¼Œå…ˆè·å–åˆå§‹ä»¤ç‰Œ
        if config_data.get(CONF_LIFESMART_AUTH_METHOD) == "password":
            _LOGGER.info("é€šè¿‡å¯†ç ç™»å½•è·å–åˆå§‹ä»¤ç‰Œ...")
            auth_response = await self.client.login_async()

        # åˆ·æ–°ä»¤ç‰Œä»¥ç¡®ä¿çŠ¶æ€åŒæ­¥
        _LOGGER.info("æ­£åœ¨åˆ·æ–°ä»¤ç‰Œä»¥ç¡®ä¿çŠ¶æ€åŒæ­¥...")
        try:
            auth_response = await self._concurrency_manager.safe_token_refresh(
                self.client.async_refresh_token
            )
            # å¦‚æœä»¤ç‰Œæœ‰æ›´æ–°ï¼ŒæŒä¹…åŒ–åˆ°é…ç½®
            if config_data.get("usertoken") != auth_response.get("usertoken"):
                config_data["usertoken"] = auth_response["usertoken"]
                await self._concurrency_manager.safe_config_update(
                    lambda: self.hass.config_entries.async_update_entry(
                        self.config_entry, data=config_data
                    )
                )
        except LifeSmartAuthError as e:
            # å¦‚æœåˆ·æ–°å¤±è´¥ä¸”ä¸æ˜¯å¯†ç ç™»å½•ï¼Œè§¦å‘é‡æ–°è®¤è¯
            if config_data.get(CONF_LIFESMART_AUTH_METHOD) != "password":
                _LOGGER.error("ä»¤ç‰Œå·²å¤±æ•ˆï¼Œéœ€è¦é‡æ–°è®¤è¯: %s", e)
                self.config_entry.async_start_reauth(self.hass)
                raise ConfigEntryNotReady("ä»¤ç‰Œå·²å¤±æ•ˆï¼Œè¯·é‡æ–°è®¤è¯ã€‚") from e

        return auth_response

    async def _setup_local_client(self) -> None:
        """è®¾ç½®æœ¬åœ° TCP å®¢æˆ·ç«¯ã€‚

        Raises:
            ConfigEntryNotReady: è¿æ¥å¤±è´¥
        """
        try:
            self.client = LifeSmartTCPClient(
                self.config_entry.data[CONF_HOST],
                self.config_entry.data[CONF_PORT],
                self.config_entry.data[CONF_USERNAME],
                self.config_entry.data[CONF_PASSWORD],
                self.config_entry.entry_id,
            )

            # åˆ›å»ºè¿æ¥ä»»åŠ¡
            self._local_task = self.hass.async_create_task(
                self.client.async_connect(self._local_update_callback)
            )

            # è·å–è®¾å¤‡åˆ—è¡¨
            self.devices = await self.client.async_get_all_devices()
            if not self.devices:
                await self._cleanup_local_task()
                raise ConfigEntryNotReady("ä»æœ¬åœ°ç½‘å…³è·å–è®¾å¤‡åˆ—è¡¨å¤±è´¥ã€‚")

        except Exception as e:
            _LOGGER.error("è®¾ç½®æœ¬åœ°è¿æ¥å¤±è´¥: %s", e, exc_info=True)
            await self._cleanup_local_task()
            raise ConfigEntryNotReady from e

    async def _local_update_callback(self, data: dict) -> None:
        """æœ¬åœ°è¿æ¥çš„æ•°æ®æ›´æ–°å›è°ƒå‡½æ•°ã€‚

        Args:
            data: æ¥æ”¶åˆ°çš„æ•°æ®
        """
        await self.data_update_handler(data)

    async def _cleanup_local_task(self) -> None:
        """æ¸…ç†æœ¬åœ°è¿æ¥ä»»åŠ¡ã€‚"""
        if self._local_task and not self._local_task.done():
            self._local_task.cancel()
            try:
                await self._local_task
            except asyncio.CancelledError:
                pass

    async def _async_register_hubs(self) -> None:
        """åœ¨è®¾å¤‡æ³¨å†Œè¡¨ä¸­æ³¨å†Œä¸­æ¢è®¾å¤‡ã€‚"""
        registry = dr.async_get(self.hass)
        hubs = {d[HUB_ID_KEY] for d in self.devices if HUB_ID_KEY in d}
        for hub_id in hubs:
            registry.async_get_or_create(
                config_entry_id=self.config_entry.entry_id,
                identifiers={(DOMAIN, hub_id)},
                manufacturer=MANUFACTURER,
                name=f"LifeSmart Hub ({hub_id[-6:]})",
                model="LifeSmart Gateway",
            )

    async def _async_setup_background_tasks(
        self, auth_response: Optional[dict]
    ) -> None:
        """è®¾ç½®åå°ä»»åŠ¡ã€‚

        Args:
            auth_response: OAPI è®¤è¯å“åº”æ•°æ®
        """
        # è®¾ç½®å®šæ—¶åˆ·æ–°ä»»åŠ¡
        self._refresh_task_unsub = async_track_time_interval(
            self.hass, self._async_periodic_refresh, timedelta(minutes=10)
        )

        # OAPI æ¨¡å¼ä¸‹è®¾ç½® WebSocket çŠ¶æ€ç®¡ç†å™¨
        if self.client and hasattr(self.client, "get_wss_url"):
            self._state_manager = LifeSmartStateManager(
                hass=self.hass,
                config_entry=self.config_entry,
                client=self.client,
                ws_url=self.client.get_wss_url(),
                refresh_callback=self._async_periodic_refresh,
                concurrency_manager=self._concurrency_manager,  # ä¼ é€’å¹¶å‘æ§åˆ¶ç®¡ç†å™¨
            )

            # è®¾ç½®ä»¤ç‰Œè¿‡æœŸæ—¶é—´
            if auth_response and "expiredtime" in auth_response:
                self._state_manager.set_token_expiry(auth_response["expiredtime"])

            self._state_manager.start()

    async def _async_periodic_refresh(self, now=None) -> None:
        """å®šæ—¶åˆ·æ–°è®¾å¤‡æ•°æ®ã€‚

        Args:
            now: å½“å‰æ—¶é—´ï¼ˆç”±å®šæ—¶å™¨ä¼ å…¥ï¼‰
        """
        try:
            _LOGGER.debug("å¼€å§‹å®šæ—¶åˆ·æ–°è®¾å¤‡æ•°æ®ã€‚")
            new_devices = await self.client.async_get_all_devices()
            self.devices = new_devices
            dispatcher_send(self.hass, LIFESMART_SIGNAL_UPDATE_ENTITY)
            _LOGGER.debug("å…¨å±€è®¾å¤‡æ•°æ®åˆ·æ–°å®Œæˆã€‚")
        except (LifeSmartAPIError, LifeSmartAuthError) as e:
            _LOGGER.warning("å›  API/è®¤è¯ é”™è¯¯ï¼Œå®šæ—¶åˆ·æ–°å¤±è´¥: %s", e)
        except Exception as e:
            _LOGGER.warning("å®šæ—¶åˆ·æ–°æ—¶å‘ç”Ÿæ„å¤–é”™è¯¯: %s", e)

    async def data_update_handler(self, raw_data: dict) -> None:
        """å¤„ç†å®æ—¶è®¾å¤‡çŠ¶æ€æ›´æ–°ã€‚

        Args:
            raw_data: ä» WebSocket æˆ–æœ¬åœ°è¿æ¥æ”¶åˆ°çš„åŸå§‹æ•°æ®
        """

        # ä½¿ç”¨å¹¶å‘æ§åˆ¶ç®¡ç†å™¨å¤„ç†è®¾å¤‡æ›´æ–°
        async def _process_update():
            try:
                data = raw_data.get("msg", {})
                if not data:
                    _LOGGER.debug("æ”¶åˆ°ç©ºæ•°æ®åŒ…ï¼Œå·²å¿½ç•¥: %s", raw_data)
                    return

                # è§£æå…³é”®å­—æ®µ
                device_type = data.get(DEVICE_TYPE_KEY, "unknown")
                hub_id = data.get(HUB_ID_KEY, "").strip()
                device_id = data.get(DEVICE_ID_KEY, "").strip()
                sub_device_key = str(data.get(SUBDEVICE_INDEX_KEY, "")).strip()

                # åº”ç”¨è¿‡æ»¤å™¨
                if self._should_filter_device(device_id, hub_id):
                    return

                # å¤„ç†ç‰¹æ®Šå­è®¾å¤‡ï¼ˆAIäº‹ä»¶ï¼‰
                if sub_device_key == "s":
                    self._handle_ai_event(data, device_id, hub_id)
                    return

                # åˆ†å‘æ™®é€šè®¾å¤‡æ›´æ–°
                unique_id = generate_unique_id(
                    device_type, hub_id, device_id, sub_device_key
                )
                dispatcher_send(
                    self.hass, f"{LIFESMART_SIGNAL_UPDATE_ENTITY}_{unique_id}", data
                )

                _LOGGER.debug(
                    "çŠ¶æ€æ›´æ–°å·²æ´¾å‘ -> %s: %s",
                    unique_id,
                    json.dumps(data, ensure_ascii=False),
                )

            except json.JSONDecodeError as e:
                _LOGGER.warning("è®¾å¤‡æ•°æ®JSONè§£æå¤±è´¥: %s", e)
                # è§¦å‘è®¾å¤‡é‡æ–°åŒæ­¥
                asyncio.create_task(self._schedule_device_sync())

            except KeyError as e:
                _LOGGER.warning("è®¾å¤‡æ•°æ®å­—æ®µç¼ºå¤±: %s", e)
                # è®°å½•è®¾å¤‡çŠ¶æ€å¼‚å¸¸
                device_type = raw_data.get("msg", {}).get(DEVICE_TYPE_KEY, "unknown")
                asyncio.create_task(self._mark_device_problematic(device_type))

            except Exception as e:
                _LOGGER.error("å¤„ç†è®¾å¤‡æ›´æ–°æ—¶å‘ç”Ÿå¼‚å¸¸: %s", e, exc_info=True)
                # è§¦å‘æ•…éšœæ¢å¤æµç¨‹
                asyncio.create_task(self._trigger_recovery_procedure(raw_data))

        await self._concurrency_manager.safe_device_update(_process_update)

    def _should_filter_device(self, device_id: str, hub_id: str) -> bool:
        """æ£€æŸ¥è®¾å¤‡æ˜¯å¦åº”è¢«è¿‡æ»¤ã€‚

        Args:
            device_id: è®¾å¤‡ ID
            hub_id: ä¸­æ¢ ID

        Returns:
            å¦‚æœåº”è¯¥è¿‡æ»¤è¿”å› True
        """
        options = self.config_entry.options
        exclude_devices = {
            dev.strip()
            for dev in options.get(CONF_EXCLUDE_ITEMS, "").split(",")
            if dev.strip()
        }
        exclude_hubs = {
            hub.strip()
            for hub in options.get(CONF_EXCLUDE_AGTS, "").split(",")
            if hub.strip()
        }
        return device_id in exclude_devices or hub_id in exclude_hubs

    def _handle_ai_event(self, data: dict, device_id: str, hub_id: str) -> None:
        """å¤„ç† AI äº‹ä»¶ã€‚

        Args:
            data: äº‹ä»¶æ•°æ®
            device_id: è®¾å¤‡ ID
            hub_id: ä¸­æ¢ ID
        """
        options = self.config_entry.options
        ai_include_hubs = {
            hub.strip()
            for hub in options.get(CONF_AI_INCLUDE_AGTS, "").split(",")
            if hub.strip()
        }
        ai_include_items = {
            item.strip()
            for item in options.get(CONF_AI_INCLUDE_ITEMS, "").split(",")
            if item.strip()
        }
        if device_id in ai_include_items and hub_id in ai_include_hubs:
            _LOGGER.info("è§¦å‘AIäº‹ä»¶: %s", data)

    async def async_unload(self) -> None:
        """å¸è½½ Hubï¼Œæ¸…ç†æ‰€æœ‰èµ„æºã€‚"""
        _LOGGER.info("æ­£åœ¨å¸è½½ LifeSmart Hub...")

        # åœæ­¢å®šæ—¶åˆ·æ–°ä»»åŠ¡
        if self._refresh_task_unsub:
            self._refresh_task_unsub()

        # åœæ­¢ WebSocket çŠ¶æ€ç®¡ç†å™¨
        if self._state_manager:
            await self._state_manager.stop()

        # æ¸…ç†æœ¬åœ°è¿æ¥
        if self.client and hasattr(self.client, "disconnect"):
            # æ£€æŸ¥ disconnect æ–¹æ³•æ˜¯å¦æ˜¯åç¨‹ï¼Œå¦‚æœæ˜¯åˆ™ç­‰å¾…
            disconnect_result = self.client.disconnect()
            if asyncio.iscoroutine(disconnect_result):
                await disconnect_result
            if self._local_task:
                self._local_task.cancel()
                try:
                    await self._local_task
                except asyncio.CancelledError:
                    pass

        # å…³é—­å¹¶å‘æ§åˆ¶ç®¡ç†å™¨
        await self._concurrency_manager.shutdown()

        _LOGGER.info("LifeSmart Hub å·²æˆåŠŸå¸è½½ã€‚")

    async def _schedule_device_sync(self):
        """è°ƒåº¦è®¾å¤‡é‡æ–°åŒæ­¥"""

        async def _sync_operation():
            try:
                _LOGGER.info("å¼€å§‹æ‰§è¡Œè®¾å¤‡é‡æ–°åŒæ­¥...")
                await asyncio.sleep(5)  # å»¶è¿Ÿ5ç§’é¿å…é¢‘ç¹åŒæ­¥
                # é‡æ–°è·å–è®¾å¤‡åˆ—è¡¨å¹¶æ›´æ–°æœ¬åœ°ç¼“å­˜
                if self.client:
                    new_devices = await self.client.async_get_all_devices()
                    self.devices = new_devices
                    # é€šçŸ¥æ‰€æœ‰å®ä½“æ›´æ–°
                    dispatcher_send(self.hass, LIFESMART_SIGNAL_UPDATE_ENTITY)
                    _LOGGER.info("è®¾å¤‡é‡æ–°åŒæ­¥å®Œæˆï¼Œæ›´æ–°äº† %d ä¸ªè®¾å¤‡", len(new_devices))
            except LifeSmartAPIError as e:
                _LOGGER.error("è®¾å¤‡åŒæ­¥APIé”™è¯¯: %s", e)
            except Exception as e:
                _LOGGER.error("è®¾å¤‡é‡æ–°åŒæ­¥å¤±è´¥: %s", e)

        await self._concurrency_manager.safe_device_sync(_sync_operation)

    async def _mark_device_problematic(self, device_type: str):
        """æ ‡è®°è®¾å¤‡å­˜åœ¨é—®é¢˜"""
        try:
            _LOGGER.warning("è®¾å¤‡ç±»å‹ %s å­˜åœ¨æ•°æ®é—®é¢˜ï¼Œå·²æ ‡è®°", device_type)
            # å®ç°è®¾å¤‡å¥åº·çŠ¶æ€è·Ÿè¸ª
            if not hasattr(self, "_problematic_devices"):
                self._problematic_devices = {}

            self._problematic_devices[device_type] = {
                "timestamp": datetime.now(),
                "count": self._problematic_devices.get(device_type, {}).get("count", 0)
                + 1,
            }

            # å¦‚æœæŸè®¾å¤‡ç±»å‹é—®é¢˜è¿‡å¤šï¼Œè€ƒè™‘æš‚æ—¶è·³è¿‡
            if self._problematic_devices[device_type]["count"] > 10:
                _LOGGER.error("è®¾å¤‡ç±»å‹ %s é—®é¢˜è¿‡å¤šï¼Œéœ€è¦äººå·¥æ£€æŸ¥", device_type)
        except Exception as e:
            _LOGGER.error("æ ‡è®°è®¾å¤‡é—®é¢˜æ—¶å¼‚å¸¸: %s", e)

    async def _trigger_recovery_procedure(self, raw_data: dict):
        """è§¦å‘æ•…éšœæ¢å¤æµç¨‹"""

        async def _recovery_operation():
            try:
                _LOGGER.info("è§¦å‘æ•…éšœæ¢å¤æµç¨‹...")

                # 1. è®°å½•æ•…éšœä¿¡æ¯
                _LOGGER.debug(
                    "æ•…éšœæ¢å¤: è®°å½•ä¿¡æ¯ - æ—¶é—´: %s, æ•°æ®: %s",
                    datetime.now().isoformat(),
                    raw_data,
                )

                # 2. å°è¯•æ¢å¤ç­–ç•¥
                await asyncio.sleep(10)  # ç»™ç³»ç»Ÿä¸€äº›æ—¶é—´ç¨³å®š

                # 3. æ£€æŸ¥WebSocketè¿æ¥çŠ¶æ€ï¼ˆä»…OAPIæ¨¡å¼ï¼‰
                if self._state_manager:
                    if hasattr(self._state_manager, "_ws") and (
                        not self._state_manager._ws or self._state_manager._ws.closed
                    ):
                        _LOGGER.info("WebSocketè¿æ¥å¼‚å¸¸ï¼Œå°†è§¦å‘é‡è¿")
                        # å¯ä»¥è§¦å‘_state_managerçš„é‡è¿é€»è¾‘

                # 4. è§¦å‘ä¸€æ¬¡è®¾å¤‡çŠ¶æ€å…¨é‡åˆ·æ–°
                await self._schedule_device_sync()

                _LOGGER.info("æ•…éšœæ¢å¤æµç¨‹å®Œæˆ")
            except Exception as e:
                _LOGGER.error("æ•…éšœæ¢å¤æµç¨‹å¼‚å¸¸: %s", e, exc_info=True)

        await self._concurrency_manager.safe_recovery_operation(_recovery_operation)

    # ä¾¿åˆ©æ–¹æ³•ï¼Œä¾›å¹³å°å®ä½“ä½¿ç”¨
    def get_devices(self) -> list[dict]:
        """è·å–è®¾å¤‡åˆ—è¡¨ã€‚

        Returns:
            è®¾å¤‡åˆ—è¡¨
        """
        return self.devices

    def get_client(self) -> LifeSmartClientBase:
        """è·å–å®¢æˆ·ç«¯å®ä¾‹ã€‚

        Returns:
            å®¢æˆ·ç«¯å®ä¾‹
        """
        return self.client

    def get_exclude_config(self) -> tuple[set[str], set[str]]:
        """è·å–æ’é™¤é…ç½®ã€‚

        Returns:
            (æ’é™¤è®¾å¤‡é›†åˆ, æ’é™¤ä¸­æ¢é›†åˆ)
        """
        options = self.config_entry.options
        exclude_devices = {
            dev.strip()
            for dev in options.get(CONF_EXCLUDE_ITEMS, "").split(",")
            if dev.strip()
        }
        exclude_hubs = {
            hub.strip()
            for hub in options.get(CONF_EXCLUDE_AGTS, "").split(",")
            if hub.strip()
        }
        return exclude_devices, exclude_hubs

    def get_concurrency_stats(self) -> Dict[str, Any]:
        """è·å–å¹¶å‘æ§åˆ¶ç»Ÿè®¡ä¿¡æ¯ï¼ˆç”¨äºè¯Šæ–­ï¼‰ã€‚"""
        return self._concurrency_manager.get_concurrency_stats()

    def get_network_stats(self) -> Dict[str, Any]:
        """è·å–ç½‘ç»œçŠ¶æ€ç»Ÿè®¡ä¿¡æ¯ï¼ˆç”¨äºè¯Šæ–­å’Œç›‘æ§ï¼‰ã€‚"""
        stats = {}
        if self._state_manager:
            stats = self._state_manager.get_network_stats()

        # æ·»åŠ Hubçº§åˆ«çš„ç½‘ç»œä¿¡æ¯
        stats.update(
            {
                "connection_type": (
                    "cloud" if hasattr(self.client, "get_wss_url") else "local"
                ),
                "total_devices": len(self.devices),
                "hub_active_since": getattr(self, "_startup_time", None),
            }
        )

        return stats


class LifeSmartStateManager:
    """LifeSmart WebSocket çŠ¶æ€ç®¡ç†å™¨ã€‚

    è´Ÿè´£ç»´æŠ¤ä¸ LifeSmart äº‘ç«¯çš„ WebSocket é•¿è¿æ¥ï¼Œå¤„ç†å®æ—¶çŠ¶æ€æ›´æ–°ã€
    è®¤è¯ã€å¿ƒè·³ç»´æŒä»¥åŠè¿æ¥ä¸­æ–­åçš„è‡ªåŠ¨é‡è¿ã€‚

    ç°å·²é›†æˆç½‘ç»œè´¨é‡æ£€æµ‹å™¨ï¼Œæ”¯æŒæ ¹æ®ç½‘ç»œçŠ¶å†µè‡ªé€‚åº”è°ƒæ•´è¿æ¥å‚æ•°ã€‚
    """

    def __init__(
        self,
        hass: HomeAssistant,
        config_entry: ConfigEntry,
        client: LifeSmartOpenAPIClient,
        ws_url: str,
        refresh_callback: Callable[[], None],
        concurrency_manager: ConcurrencyManager,
        retry_interval: int = 10,
        max_retries: int = 60,
    ) -> None:
        """åˆå§‹åŒ– WebSocket çŠ¶æ€ç®¡ç†å™¨ã€‚

        Args:
            hass: Home Assistant æ ¸å¿ƒå®ä¾‹
            config_entry: é›†æˆé…ç½®æ¡ç›®
            client: OAPI å®¢æˆ·ç«¯å®ä¾‹
            ws_url: WebSocket è¿æ¥åœ°å€
            refresh_callback: å…¨é‡åˆ·æ–°å›è°ƒå‡½æ•°
            concurrency_manager: å¹¶å‘æ§åˆ¶ç®¡ç†å™¨
            retry_interval: åˆå§‹é‡è¯•é—´éš”ï¼ˆç§’ï¼‰- ç°åœ¨ä¼šæ ¹æ®ç½‘ç»œè´¨é‡åŠ¨æ€è°ƒæ•´
            max_retries: æœ€å¤§é‡è¯•æ¬¡æ•° - ç°åœ¨ä¼šæ ¹æ®ç½‘ç»œè´¨é‡åŠ¨æ€è°ƒæ•´
        """
        self.hass = hass
        self.config_entry = config_entry
        self.client = client
        self.ws_url = ws_url
        self.refresh_callback = refresh_callback
        self.retry_interval = retry_interval
        self.max_retries = max_retries
        self._concurrency_manager = concurrency_manager

        # åˆå§‹åŒ–ç½‘ç»œè´¨é‡æ£€æµ‹å™¨
        network_mode = config_entry.options.get(CONF_WS_NETWORK_MODE, "auto")
        self._network_detector = NetworkQualityDetector(network_mode)

        # WebSocketè¿æ¥ç›¸å…³
        self._ws: Optional[aiohttp.ClientWebSocketResponse] = None
        self._connection_lock = self._concurrency_manager._connection_lock
        self._retry_count = 0
        self._ws_task: Optional[asyncio.Task] = None
        self._token_task: Optional[asyncio.Task] = None
        self._should_stop = False
        self._last_disconnect_time: Optional[datetime] = None
        self._token_expiry_time: int = 0
        self._token_refresh_event = asyncio.Event()

        # ç½‘ç»œè´¨é‡ç›¸å…³çŠ¶æ€
        self._current_network_quality = "normal"
        self._last_quality_check = 0

        # è·å–ç”¨æˆ·è‡ªå®šä¹‰é…ç½®
        self._custom_heartbeat_interval = config_entry.options.get(
            CONF_WS_HEARTBEAT_INTERVAL
        )
        self._custom_max_reconnect_attempts = config_entry.options.get(
            CONF_WS_MAX_RECONNECT_ATTEMPTS
        )

    def start(self) -> None:
        """å¯åŠ¨ WebSocket è¿æ¥å’Œä»¤ç‰Œåˆ·æ–°ç®¡ç†å¾ªç¯ã€‚"""
        if not self._ws_task or self._ws_task.done():
            self._should_stop = False
            self._ws_task = self.hass.loop.create_task(self._connection_handler())
            _LOGGER.info("LifeSmart WebSocket çŠ¶æ€ç®¡ç†å™¨å·²å¯åŠ¨ã€‚")
        if not self._token_task or self._token_task.done():
            self._token_task = self.hass.loop.create_task(self._token_refresh_handler())
            _LOGGER.info("LifeSmart ä»¤ç‰Œåˆ·æ–°ç®¡ç†å™¨å·²å¯åŠ¨ã€‚")

    def set_token_expiry(self, expiry_timestamp: int):
        """è®¾ç½®ä»¤ç‰Œçš„è¿‡æœŸæ—¶é—´æˆ³ã€‚

        Args:
            expiry_timestamp: è¿‡æœŸæ—¶é—´æˆ³
        """
        self._token_expiry_time = expiry_timestamp
        self._token_refresh_event.set()
        _LOGGER.info(
            "ä»¤ç‰Œè¿‡æœŸæ—¶é—´å·²è®¾ç½®ä¸º: %s", datetime.fromtimestamp(expiry_timestamp)
        )

    async def _connection_handler(self):
        """ä¸»è¿æ¥å¤„ç†å¾ªç¯ã€‚"""
        while not self._should_stop and self._retry_count <= self.max_retries:
            try:
                # ä½¿ç”¨å¹¶å‘æ§åˆ¶ç®¡ç†å™¨ä¿æŠ¤è¿æ¥æ“ä½œ
                async def _connect_operation():
                    _LOGGER.info("æ­£åœ¨å°è¯•å»ºç«‹ WebSocket è¿æ¥...")
                    self._ws = await self._create_websocket()
                    _LOGGER.info("WebSocket åº•å±‚è¿æ¥å·²å»ºç«‹ï¼Œæ­£åœ¨è¿›è¡Œè®¤è¯...")
                    await self._perform_auth()
                    _LOGGER.info("è®¤è¯æˆåŠŸï¼Œå¼€å§‹ç›‘å¬æ¶ˆæ¯...")
                    await self._message_consumer()

                await self._concurrency_manager.safe_connection_operation(
                    _connect_operation
                )

            except PermissionError as e:
                _LOGGER.critical("WebSocket è®¤è¯å¤±è´¥ï¼Œä¸å¯æ¢å¤çš„é”™è¯¯: %s", e)
                break

            except aiohttp.ClientResponseError as e:
                if e.status == 401:
                    _LOGGER.error("WebSocketè®¤è¯å¤±è´¥ï¼Œæ£€æŸ¥ä»¤ç‰Œæœ‰æ•ˆæ€§: %s", e)
                    # è§¦å‘é‡æ–°è®¤è¯æµç¨‹
                    break
                elif e.status >= 500:
                    _LOGGER.warning("æœåŠ¡å™¨é”™è¯¯(%d)ï¼Œå°†é‡è¯•: %s", e.status, e)
                    await self._schedule_retry()
                else:
                    _LOGGER.error("å®¢æˆ·ç«¯è¯·æ±‚é”™è¯¯(%d): %s", e.status, e)
                    break

            except (ConnectionError, aiohttp.ClientOSError) as e:
                _LOGGER.warning("ç½‘ç»œè¿æ¥é—®é¢˜ï¼Œå°†é‡è¯•: %s", e)
                await self._schedule_retry()

            except (aiohttp.ClientError, asyncio.TimeoutError) as e:
                _LOGGER.warning(
                    "WebSocket ç½‘ç»œé”™è¯¯ï¼Œå°†è¿›è¡Œé‡è¯• (%d/%d): %s",
                    self._retry_count + 1,
                    self.max_retries,
                    e,
                )
                await self._schedule_retry()

            except json.JSONDecodeError as e:
                _LOGGER.error("æœåŠ¡å™¨å“åº”æ ¼å¼é”™è¯¯: %s", e)
                await self._schedule_retry()

            except asyncio.CancelledError:
                _LOGGER.info("WebSocket è¿æ¥ä»»åŠ¡è¢«å–æ¶ˆ")
                raise  # ä¸åº”è¯¥æ•è·å–æ¶ˆå¼‚å¸¸

            except Exception as e:
                # åªä¿ç•™çœŸæ­£æ— æ³•é¢„æ–™çš„å¼‚å¸¸
                error_type = type(e).__name__
                _LOGGER.error(
                    "WebSocketè¿æ¥å¤„ç†å™¨å‘ç”Ÿæœªé¢„æœŸçš„%så¼‚å¸¸: %s",
                    error_type,
                    e,
                    exc_info=True,
                )

                # é™åˆ¶æœªçŸ¥å¼‚å¸¸çš„é‡è¯•æ¬¡æ•°
                if not hasattr(self, "_unknown_error_count"):
                    self._unknown_error_count = 0

                self._unknown_error_count += 1
                if self._unknown_error_count > 3:
                    _LOGGER.error(
                        "æœªçŸ¥å¼‚å¸¸è¿‡å¤š(%dæ¬¡)ï¼Œåœæ­¢é‡è¯•", self._unknown_error_count
                    )
                    break

                await self._schedule_retry()

    async def _create_websocket(self) -> aiohttp.ClientWebSocketResponse:
        """åˆ›å»ºæ–°çš„ WebSocket è¿æ¥ã€‚

        Returns:
            WebSocket è¿æ¥å®ä¾‹

        Raises:
            aiohttp.ClientConnectorCertificateError: SSL è¯ä¹¦éªŒè¯å¤±è´¥
        """
        session = async_get_clientsession(self.hass)

        # è·å–å½“å‰ç½‘ç»œè´¨é‡çš„è¶…æ—¶é…ç½®
        timeout_config = self._network_detector.get_timeout_config(
            self._current_network_quality
        )
        heartbeat_interval = self._get_heartbeat_interval()

        _LOGGER.debug(
            "åˆ›å»ºWebSocketè¿æ¥ - ç½‘ç»œè´¨é‡: %s, å¿ƒè·³é—´éš”: %ds, æ¥æ”¶è¶…æ—¶: %ds",
            self._current_network_quality,
            heartbeat_interval,
            timeout_config["receive"],
        )

        try:
            return await session.ws_connect(
                self.ws_url,
                heartbeat=heartbeat_interval,
                compress=15,
                timeout=get_ws_timeout(timeout_config["receive"]),
            )
        except aiohttp.ClientConnectorCertificateError as e:
            _LOGGER.error("è¯ä¹¦éªŒè¯å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨åŒºåŸŸè®¾ç½®: %s", e)
            raise

    async def _perform_auth(self):
        """æ‰§è¡Œ WebSocket è®¤è¯æµç¨‹ã€‚

        Raises:
            PermissionError: è®¤è¯å¤±è´¥
        """
        timeout_config = self._network_detector.get_timeout_config(
            self._current_network_quality
        )
        auth_timeout = timeout_config["auth"]

        auth_payload = self.client.generate_wss_auth()
        _LOGGER.debug("å‘é€ WebSocket è®¤è¯è½½è·: %s", auth_payload)
        await self._ws.send_str(auth_payload)

        response = await self._ws.receive(timeout=auth_timeout)
        if response.type != aiohttp.WSMsgType.TEXT:
            raise PermissionError(f"æœåŠ¡å™¨è¿”å›äº†éé¢„æœŸçš„å“åº”ç±»å‹: {response.type}")

        data = json.loads(response.data)
        _LOGGER.debug("æ”¶åˆ° WebSocket è®¤è¯å“åº”: %s", data)

        if not (data.get("code") == 0 and data.get("message") == "success"):
            error_msg = data.get("message", "æœªçŸ¥è®¤è¯é”™è¯¯")
            raise PermissionError(f"è®¤è¯è¢«æœåŠ¡å™¨æ‹’ç»: {error_msg}")

        _LOGGER.info("âœ… WebSocket è®¤è¯æˆåŠŸã€‚")

        # å¤„ç†æ–­çº¿é‡è¿åçš„å…¨é‡åˆ·æ–°
        if self._last_disconnect_time:
            disconnect_duration = datetime.now() - self._last_disconnect_time
            if disconnect_duration > timedelta(minutes=30):
                _LOGGER.warning(
                    "WebSocket æ–­å¼€å·²è¶…è¿‡ %d åˆ†é’Ÿï¼Œå°†è§¦å‘ä¸€æ¬¡å…¨é‡è®¾å¤‡åˆ·æ–°ã€‚",
                    int(disconnect_duration.total_seconds() / 60),
                )
                self.hass.loop.create_task(self.refresh_callback())

        # è¿æ¥æˆåŠŸåé‡ç½®çŠ¶æ€
        self._last_disconnect_time = None
        self._retry_count = 0

    async def _message_consumer(self):
        """æŒç»­æ¶ˆè´¹æ¥è‡ª WebSocket çš„æ¶ˆæ¯ã€‚

        Raises:
            asyncio.CancelledError: ä»»åŠ¡è¢«å–æ¶ˆ
        """
        try:
            async for msg in self._ws:
                if msg.type == aiohttp.WSMsgType.TEXT:
                    # ä½¿ç”¨å¹¶å‘æ§åˆ¶ç®¡ç†å™¨å¤„ç†æ¶ˆæ¯
                    await self._concurrency_manager.safe_message_processing(
                        self._process_text_message, msg.data
                    )
                elif msg.type in (aiohttp.WSMsgType.ERROR, aiohttp.WSMsgType.CLOSED):
                    _LOGGER.warning("WebSocket è¿æ¥å·²å…³é—­æˆ–å‡ºé”™ï¼Œå°†é‡æ–°è¿æ¥ã€‚")
                    break
        except asyncio.CancelledError:
            _LOGGER.info("WebSocket æ¶ˆæ¯ç›‘å¬ä»»åŠ¡å·²è¢«å–æ¶ˆã€‚")
            raise
        except Exception:
            _LOGGER.error("åœ¨æ¶ˆæ¯æ¶ˆè´¹å¾ªç¯ä¸­å‘ç”Ÿå¼‚å¸¸ï¼Œå°†é‡æ–°è¿æ¥ã€‚")
            raise

    async def _process_text_message(self, raw_data: str):
        """å¤„ç†å•æ¡æ–‡æœ¬æ¶ˆæ¯ã€‚

        Args:
            raw_data: åŸå§‹æ¶ˆæ¯æ•°æ®
        """
        try:
            _LOGGER.debug("æ”¶åˆ° WebSocket æ¶ˆæ¯: %s", raw_data)
            data = json.loads(raw_data)
            if data.get("type") == "io":
                # é€šè¿‡ hass.data è·å– hub å®ä¾‹
                hub = self.hass.data[DOMAIN][self.config_entry.entry_id]["hub"]
                await hub.data_update_handler(data)
        except json.JSONDecodeError:
            _LOGGER.warning("æ— æ³•è§£ææ”¶åˆ°çš„ WebSocket æ¶ˆæ¯: %s", raw_data[:200])
        except Exception as e:
            _LOGGER.error("å¤„ç† WebSocket æ¶ˆæ¯æ—¶å‘ç”Ÿé”™è¯¯: %s", e)

    async def _schedule_retry(self):
        """è°ƒåº¦ä¸‹ä¸€æ¬¡é‡è¿å°è¯•ã€‚"""
        if self._last_disconnect_time is None:
            self._last_disconnect_time = datetime.now()

        self._retry_count += 1
        max_attempts = self._get_max_reconnect_attempts()

        if self._retry_count > max_attempts:
            _LOGGER.error("å·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•° (%s)ï¼Œå°†åœæ­¢å°è¯•è¿æ¥ã€‚", max_attempts)
            return

        # ä½¿ç”¨æ™ºèƒ½é‡è¿å»¶è¿Ÿè®¡ç®—
        timeout_config = self._network_detector.get_timeout_config(
            self._current_network_quality
        )
        base_delay = timeout_config["reconnect_base"]

        delay = calculate_reconnect_delay(
            self._retry_count, base_delay, self._current_network_quality
        )

        _LOGGER.info(
            "WebSocket è¿æ¥æ–­å¼€ï¼Œå°†åœ¨ %.1f ç§’åè¿›è¡Œç¬¬ %d æ¬¡é‡è¯• (ç½‘ç»œè´¨é‡: %s)ã€‚",
            delay,
            self._retry_count,
            self._current_network_quality,
        )
        await asyncio.sleep(delay)

    async def _token_refresh_handler(self):
        """åå°ä»»åŠ¡ï¼Œå®šæœŸæ£€æŸ¥å’Œåˆ·æ–°ä»¤ç‰Œã€‚"""
        await asyncio.sleep(60)  # å¯åŠ¨åç­‰å¾…

        # é…ç½®å¸¸é‡ - é¿å…ç¡¬ç¼–ç 
        TOKEN_CHECK_INTERVAL_SECONDS = 3600  # 1å°æ—¶æ£€æŸ¥ä¸€æ¬¡
        TOKEN_REFRESH_THRESHOLD_DAYS = 275  # 275å¤©æå‰åˆ·æ–°

        check_interval_seconds = TOKEN_CHECK_INTERVAL_SECONDS

        while not self._should_stop:
            try:
                # ç­‰å¾…ä»¤ç‰Œè¿‡æœŸæ—¶é—´è®¾ç½®
                if self._token_expiry_time == 0:
                    await asyncio.sleep(check_interval_seconds)
                    continue

                now = int(time.time())
                time_to_expiry = self._token_expiry_time - now
                refresh_threshold = TOKEN_REFRESH_THRESHOLD_DAYS * 24 * 3600

                if time_to_expiry < refresh_threshold:
                    _LOGGER.info(
                        "ä»¤ç‰Œå³å°†åœ¨ %.1f å°æ—¶å†…è¿‡æœŸï¼Œå¼€å§‹åˆ·æ–°...", time_to_expiry / 3600
                    )

                    # ä½¿ç”¨å¹¶å‘æ§åˆ¶ç®¡ç†å™¨è¿›è¡Œä»¤ç‰Œåˆ·æ–°å’Œé…ç½®æ›´æ–°
                    try:
                        new_token_data = (
                            await self._concurrency_manager.safe_token_refresh(
                                self.client.async_refresh_token
                            )
                        )

                        # æ›´æ–°é…ç½®å¹¶è®¾ç½®æ–°çš„è¿‡æœŸæ—¶é—´
                        current_data = self.config_entry.data.copy()
                        current_data[CONF_LIFESMART_USERTOKEN] = new_token_data[
                            "usertoken"
                        ]

                        await self._concurrency_manager.safe_config_update(
                            lambda: self.hass.config_entries.async_update_entry(
                                self.config_entry, data=current_data
                            )
                        )

                        self.set_token_expiry(new_token_data["expiredtime"])
                        _LOGGER.info("ä»¤ç‰Œåˆ·æ–°æˆåŠŸã€‚")

                    except LifeSmartAuthError as e:
                        _LOGGER.error("è‡ªåŠ¨åˆ·æ–°ä»¤ç‰Œå¤±è´¥: %sã€‚å°†åœ¨1å°æ—¶åé‡è¯•ã€‚", e)
                else:
                    _LOGGER.debug(
                        "ä»¤ç‰Œæœ‰æ•ˆæœŸå……è¶³ (å‰©ä½™ %.1f å°æ—¶)ã€‚",
                        time_to_expiry / 3600,
                    )

                await asyncio.sleep(check_interval_seconds)

            except asyncio.CancelledError:
                _LOGGER.info("ä»¤ç‰Œåˆ·æ–°ä»»åŠ¡å·²è¢«å–æ¶ˆã€‚")
                break
            except Exception as e:
                _LOGGER.error("ä»¤ç‰Œåˆ·æ–°å¤„ç†å™¨å‘ç”Ÿå¼‚å¸¸: %sã€‚", e)
                await asyncio.sleep(check_interval_seconds)

    async def stop(self):
        """åœæ­¢ WebSocket è¿æ¥å’Œç®¡ç†ä»»åŠ¡ã€‚"""
        _LOGGER.info("æ­£åœ¨åœæ­¢ LifeSmart WebSocket çŠ¶æ€ç®¡ç†å™¨...")
        self._should_stop = True

        # 1. å®‰å…¨å…³é—­ WebSocket è¿æ¥ï¼Œæ”¹è¿›èµ„æºæ¸…ç†
        if self._ws and not self._ws.closed:
            try:
                # è·å–å½“å‰ç½‘ç»œè´¨é‡çš„è¶…æ—¶é…ç½®
                timeout_config = self._network_detector.get_timeout_config(
                    self._current_network_quality
                )
                close_timeout = timeout_config["close"]
                heartbeat_timeout = timeout_config["heartbeat"]

                # å…ˆå‘é€å…³é—­å¸§
                await asyncio.wait_for(self._ws.close(code=1000), timeout=close_timeout)
                # ç­‰å¾…è¿æ¥å®Œå…¨å…³é—­
                await asyncio.wait_for(self._ws.wait_for_close(), timeout=close_timeout)
                _LOGGER.debug("WebSocketè¿æ¥å·²æ­£å¸¸å…³é—­")
            except asyncio.TimeoutError:
                _LOGGER.warning("WebSocketå…³é—­è¶…æ—¶ï¼Œè¿›è¡Œå¼ºåˆ¶æ¸…ç†")
            except Exception as e:
                _LOGGER.error("WebSocketå…³é—­å¼‚å¸¸: %s", e)
            finally:
                # æ¸…ç†å¼•ç”¨ä½†ä¸ç›´æ¥è®¾ç½®ä¸ºNoneï¼ˆé¿å…å†…å­˜æ³„æ¼ï¼‰
                self._ws = None

        # 2. æ”¶é›†å¹¶å–æ¶ˆæ‰€æœ‰ä»»åŠ¡
        tasks_to_cancel = []
        if hasattr(self, "_ws_task") and self._ws_task and not self._ws_task.done():
            self._ws_task.cancel()
            tasks_to_cancel.append(self._ws_task)
        if (
            hasattr(self, "_token_task")
            and self._token_task
            and not self._token_task.done()
        ):
            self._token_task.cancel()
            tasks_to_cancel.append(self._token_task)

        # 3. ç­‰å¾…ä»»åŠ¡å®Œæˆï¼Œè®¾ç½®è¶…æ—¶å’Œå¼‚å¸¸å¤„ç†
        if tasks_to_cancel:
            try:
                done, pending = await asyncio.wait_for(
                    asyncio.wait(tasks_to_cancel, return_when=asyncio.ALL_COMPLETED),
                    timeout=heartbeat_timeout,
                )
                # æ£€æŸ¥æ˜¯å¦æœ‰ä»»åŠ¡å¼‚å¸¸å®Œæˆ
                for task in done:
                    if task.exception() and not isinstance(
                        task.exception(), asyncio.CancelledError
                    ):
                        _LOGGER.warning("ä»»åŠ¡å¼‚å¸¸ç»“æŸ: %s", task.exception())
            except asyncio.TimeoutError:
                _LOGGER.warning(
                    "ä»»åŠ¡å–æ¶ˆè¶…æ—¶ï¼Œä»æœ‰ %d ä¸ªä»»åŠ¡æœªå®Œæˆ", len(tasks_to_cancel)
                )
                # å¼ºåˆ¶ç»ˆæ­¢ä»ç„¶è¿è¡Œçš„ä»»åŠ¡
                for task in tasks_to_cancel:
                    if not task.done():
                        task.cancel()

        _LOGGER.info("LifeSmart çŠ¶æ€ç®¡ç†å™¨å·²å®Œå…¨åœæ­¢ã€‚")

    async def _update_network_quality(self):
        """æ›´æ–°ç½‘ç»œè´¨é‡æ£€æµ‹ã€‚"""
        try:
            new_quality = await self._network_detector.detect_network_quality(
                self.ws_url
            )
            if new_quality != self._current_network_quality:
                _LOGGER.info(
                    "ç½‘ç»œè´¨é‡å˜åŒ–: %s -> %s, è°ƒæ•´è¿æ¥å‚æ•°",
                    self._current_network_quality,
                    new_quality,
                )
                self._current_network_quality = new_quality
                # é‡ç½®é‡è¯•è®¡æ•°å™¨ï¼Œç»™æ–°çš„ç½‘ç»œç¯å¢ƒæ›´å¤šæœºä¼š
                self._retry_count = max(0, self._retry_count - 5)
        except Exception as e:
            _LOGGER.warning("ç½‘ç»œè´¨é‡æ£€æµ‹å¤±è´¥: %s", e)

    def _get_max_reconnect_attempts(self) -> int:
        """è·å–æœ€å¤§é‡è¿æ¬¡æ•°ï¼ˆè€ƒè™‘ç”¨æˆ·è‡ªå®šä¹‰é…ç½®ï¼‰ã€‚"""
        if self._custom_max_reconnect_attempts:
            return self._custom_max_reconnect_attempts
        return self._network_detector.get_max_reconnect_attempts(
            self._current_network_quality
        )

    def _get_heartbeat_interval(self) -> int:
        """è·å–å¿ƒè·³é—´éš”ï¼ˆè€ƒè™‘ç”¨æˆ·è‡ªå®šä¹‰é…ç½®ï¼‰ã€‚"""
        if self._custom_heartbeat_interval:
            return self._custom_heartbeat_interval
        return self._network_detector.get_heartbeat_interval(
            self._current_network_quality
        )

    def get_network_stats(self) -> Dict[str, Any]:
        """è·å–ç½‘ç»œè´¨é‡ç»Ÿè®¡ä¿¡æ¯ã€‚"""
        return {
            "current_quality": self._current_network_quality,
            "detector_stats": self._network_detector.get_stats(),
            "retry_count": self._retry_count,
            "max_retries": self._get_max_reconnect_attempts(),
            "heartbeat_interval": self._get_heartbeat_interval(),
        }
